# -*- coding: utf-8 -*-
"""adex_basin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mbNtNVWmM3nUMFVgPIwWZYXug-Pxp_ds
"""

pip install dcor

pip install brian2

# Commented out IPython magic to ensure Python compatibility.
from brian2 import *
import dcor
import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt

init_time = 1*second
defaultclock.dt = 0.01*ms

from google.colab import drive
drive.mount('/content/drive')

dtype = [("time", float), ("vm", float)]
path = "/content"
b1_ = np.genfromtxt(path + "/basin1-1.csv" , delimiter = ",", dtype=dtype)
b2_ = np.genfromtxt(path + "/basin1-2.csv" , delimiter = ",", dtype=dtype)
b3_ = np.genfromtxt(path + "/basin1-3.csv" , delimiter = ",", dtype=dtype)
b4_ = np.genfromtxt(path + "/basin1-4.csv" , delimiter = ",", dtype=dtype)
b5_ = np.genfromtxt(path + "/basin1-5.csv" , delimiter = ",", dtype=dtype)
b6_ = np.genfromtxt(path + "/basin1-6.csv" , delimiter = ",", dtype=dtype)
b7_ = np.genfromtxt(path + "/basin1-7.csv" , delimiter = ",", dtype=dtype)
b8_ = np.genfromtxt(path + "/basin1-8.csv" , delimiter = ",", dtype=dtype)
b9_ = np.genfromtxt(path + "/basin1-9.csv" , delimiter = ";", dtype=dtype)
b10_ = np.genfromtxt(path + "/basin1-10.csv" , delimiter = ";", dtype=dtype)
b11_ = np.genfromtxt(path + "/basin1-11.csv" , delimiter = ";", dtype=dtype)
b12_ = np.genfromtxt(path + "/basin1-12.csv" , delimiter = ",", dtype=dtype)
b13_ = np.genfromtxt(path + "/basin1-13.csv" , delimiter = ",", dtype=dtype)

def preprocess1(df):
    df["time"] = 100*df["time"]
    df["vm"] = 20*df["vm"]-36
    df = np.sort(df, order = "time")
    n_values = np.arange(0, init_time/ms, defaultclock.dt/ms)
    #n = round(init_time/ms/defaultclock.dt*ms)
    #n_values = np.arange(0, init_time/ms+0.01, defaultclock.dt/ms)
    df = np.interp(n_values, df["time"], df["vm"])
    return df

def preprocess2(df):
    f = np.sort(df, order = "time")
    n_values = np.arange(0, init_time/ms, defaultclock.dt/ms)
    #n = round(init_time/ms/defaultclock.dt*ms)
    #n_values = np.arange(0, init_time/ms+0.01, defaultclock.dt/ms)
    df = np.interp(n_values, df["time"], df["vm"])
    return df

b1 = preprocess1(b1_)
b2 = preprocess1(b2_)
b3 = preprocess1(b3_)
b4 = preprocess1(b4_)
b5 = preprocess1(b5_)
b6 = preprocess1(b6_)
b7 = preprocess1(b7_)
b8 = preprocess1(b8_)
b9 = preprocess2(b9_)
b10 = preprocess2(b10_)
b11 = preprocess2(b11_)
b12 = preprocess1(b12_)
b13 = preprocess1(b13_)
basin_recordings = [b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12]

# start_scope()

defaultclock.dt = 0.01*ms

C = 0.016*nF      #0.015-0.017                     #check consider incertitude in paper
gL = 0.3*nS      #0.1-30             #ok
EL = -30*mV                           #check
VT = 10*mV                            #check
DeltaT = 2*mV #2.5*mV                 #0.1-5*mV
tauw = 70*ms #10*ms                   #10-350
a = 0.1*nS                          #-15-30
b = 0.001*nA                              #0-400
#I = 14*pA #1 barre = 2pA, 12pa = +24mv              #check #dÃ©but de spikes Ã  12pA, 30mv
N=1

init_time = 1*second



eqs = """
dvm/dt=(-gL*(vm-EL)+gL*DeltaT*exp((vm-VT)/DeltaT)+I-w)/C : volt
dw/dt=(a*(vm-EL)-w)/tauw : amp
Vr:volt
I = I_recorded(t) : amp
"""
#1er pallier de Vm = 8.6mv. 7cm = 20 mV


neuron = NeuronGroup(N, model=eqs, threshold='vm > VT',
                     reset="vm = Vr; w += b", method='euler')
neuron.vm = -29.977359887770966*mV
neuron.w = a * (neuron.vm - EL)
neuron.Vr = VT-3*mV                   #check

states = StateMonitor(neuron, "vm", record=True, when='start')
spikes = SpikeMonitor(neuron, variables="vm")
store()

C_range = np.arange(0.015,0.017, 0.001)
a_range = np.arange(0.1, 0.5, 0.05)
gL_range = np.arange(0.27, 0.31, 0.01)
dtype_params = [("a", float), ("C", float), ("gL", float)]
params = np.zeros(len(C_range)*len(a_range)*len(gL_range), dtype = dtype_params)
params["a"] = np.repeat(a_range.reshape((1,8)),len(C_range)*len(gL_range)
          ,axis=0).reshape((len(C_range)*len(a_range)*len(gL_range)))
params["C"] = np.tile(np.repeat(C_range.reshape((1,3)),8),4)
params["gL"] = np.repeat(gL_range,len(C_range)*len(a_range))

# params b13, tauw, a, b, deltat

C_range = np.arange(0.015,0.017, 0.001)
a_range = np.arange(0.1, 0.5, 0.05)
tau_range = np.arange(10, 65, 5)
b_range = np.arange(0.001,2,0.05)
deltat_range = np.arange(0.001,2,0.05)
gL_range = np.arange(0.27, 0.31, 0.01)
dtype_params = [("C", float), ("a", float), ("gL", float), ("tauw", float),
                ("b", float), ("deltat", float)]
params2 = np.zeros(len(C_range)*len(a_range)*len(tau_range)*
                  len(b_range)*len(deltat_range)*len(gL_range), dtype = dtype_params)
params2["a"] = np.repeat(a_range.reshape((1,len(a_range))),len(C_range)*
                                      len(gL_range)*len(tau_range)*len(b_range)*len(deltat_range)
          ,axis=0).reshape((len(C_range)*len(a_range)*len(gL_range)*
                            len(tau_range)*len(b_range)*len(deltat_range)))
params2["C"] = np.tile(np.repeat(C_range.reshape((1,len(C_range))),len(a_range)),
                      len(gL_range)*len(deltat_range)*len(tau_range)*len(b_range))
params2["tauw"] = np.tile(np.repeat(tau_range.reshape((1,len(tau_range))),
                                        len(a_range)*len(C_range)),
                              len(gL_range)*len(deltat_range)*len(b_range))
params2["b"] = np.tile(np.repeat(b_range.reshape((1,len(b_range))),
                                        len(a_range)*len(C_range)*len(tau_range)),
                              len(gL_range)*len(deltat_range))
params2["deltat"] = np.tile(np.repeat(b_range.reshape((1,len(deltat_range))),
                                        len(a_range)*len(C_range)*len(tau_range)*len(b_range)),
                              len(gL_range))
params2["gL"] = np.repeat(gL_range,len(a_range)*len(tau_range)*
                  len(b_range)*len(deltat_range)*len(C_range))

basin_recordings = [b7, b8, b9, b10, b11, b12, b13]

I_arr = zeros(round(init_time/ms/defaultclock.dt*ms)+4000)*pA
I_recorded = TimedArray(I_arr, dt=defaultclock.dt)


I_values = np.arange(4,17,2) # pA to 16 pA. 16pA for b13
names = ["b7", "b8", "b9", "b10", "b11", "b12", "b13"]
paths = ["basin1_7", "basin1_8", "basin1_9", "basin1_10", "basin1_11", "basin1_12", "basin1_13"]
for i,j,k,l in zip(I_values, basin_recordings, names, paths):
    I_arr[0:77000] = i*pA
    I_recorded = TimedArray(I_arr, dt=defaultclock.dt)
    basin = j
    name = k
    path_ = l

    if names != "b13":
        for x in range(len(params)):
            restore()
            a = params[x][0]*nS
            C = params[x][1]*nF
            gL = params[x][2]*nS
            run(init_time) #, report='text')

            score = dcor.distance_correlation(basin, states.vm[0]/mV)
            plot(states.t/ms, states.vm[0]/mV, '-b')
            plot(spikes.t/ms, spikes.vm/mV, 'ob')
            plot(states.t/ms, basin)
            xlabel('Time (ms)')
            ylabel('v (mV)')
            if score > 0.96:
                savefig(path + path_ +"/match/%s_C=%s_a=%s_gL%s.png" %
                (name, str(C), str(a), str(gL)))
                close()
            else:
                savefig(path + path_ +"/nope/%s_C=%s_a=%s_gL%s.png" %
                (name, str(C), str(a), str(gL)))
                close()
                params[x][0] = 0
                params[x][1] = 0
                params[x][2] = 0
    else:
        dtype_params = [("C", float), ("a", float), ("gL", float), ("tauw", float),
                ("b", float), ("deltat", float)]
        dtype2 = [("tauw", float), ("b", float), ("deltat", float)]
        params2 = np.zeros(len(tau_range)*len(b_range)*len(deltat_range), dtype = dtype2)
        params2["tauw"] = np.repeat(tau_range.reshape((1,len(tau_range))),len(b_range)*len(deltat_range)
          ,axis=0).reshape((len(tau_range)*len(b_range)*len(deltat_range)))
        params2["b"] = np.tile(np.repeat(b_range.reshape((1,len(b_range))),len(tau_range)),len(deltat_range))
        params2["deltat"] = np.repeat(deltat_range,len(b_range)*len(tau_range))
        params3 = np.array(0, dtype = dtype_params)
        for x in range(len(params)) :
            a = params[x][0]*nS
            C = params[x][1]*nF
            gL = params[x][2]*nS
            for y in range(len(params2)):
                restore()
                tauw = params2[y][0]*ms
                b =  params2[y][1]*nA
                deltat = params2[y][2]*mV
                run(init_time) #, report='text')

                score = dcor.distance_correlation(basin, states.vm[0]/mV)
                plot(states.t/ms, states.vm[0]/mV, '-b')
                plot(spikes.t/ms, spikes.vm/mV, 'ob')
                plot(states.t/ms, basin)
                xlabel('Time (ms)')
                ylabel('v (mV)')
                if score > 0.96:
                    savefig(path + path_ + "/match/%s_C=%s_a=%s_gL=%s_deltat=%s_tauw=%s_b=%s.png" %
                    (name, str(C), str(a), str(gL), str(deltat), str(tauw),str(b)))
                    close()
                    params3 = np.hstack((params3,np.array(0, dtype = dtype_params)))
                    params3["gL"][x] = gL
                    params3["a"][x] = a
                    params3["C"][x] = C
                    params3["tauw"][x] = tauw
                    params3["b"][x] = b
                    params3["deltat"][x] = deltat
                else:
                    savefig(path + "basin1_13/nope/%s_C=%s_a=%s_gL=%s_deltat=%s_tauw=%s_b=%s.png" %
                    (name, str(C), str(a), str(gL), str(deltat), str(tauw),str(b)))
                    close()
    params = params[np.nonzero(params)]